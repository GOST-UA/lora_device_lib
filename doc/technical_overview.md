Technical Overview
==================

## Modules

LoraDeviceLib (LDL) is composed of the following modules:

![image missing](/doc/plantuml/modules.png "LoraDeviceLib Modules")

- Each module can be isolated for testing
- Useful modules (like Frame) are easy to extract and reuse in other projects
- Modules are written in an OO style     
- It is possible to have more than one instance of LDL in the same program
    
## Execution

LDL is intended to be driven from two tasks; an _interrupt_ level task and a _mainloop_ level task. 

The _interrupt_ level task signals when IO events occur. It runs for a short time and never blocks. The _interrupt_ level task must never
be interrupted by the _mainloop_ level task. 

The _mainloop_ level task drives all other functionality from a single thread. 
There are a small number of critical sections between the _interrupt_ level and _mainloop_ level threads - the _mainloop_ level task
must use atomic operations when accessing these sections.

To perform a MAC operation, the application must first schedule the operation by calling a scheduling function (e.g. MAC.join()), and then action the operation
by calling MAC.tick() one or more times until a callback is received. 

The application must decide when to call MAC.tick() so that events are not missed. It can use MAC.ticksUntilNextEvent()
to work out the best time to call, or, simply poll MAC.tick() as often as possible from _mainloop_.

Sometimes MAC will be waiting on an IO event (generated by the radio hardware). The _interrupt_ task must be implemented in such a way
that it calls MAC.radioEvent() as well as signaling _mainloop_ to call MAC.tick() at the next opportunity. 

## Timing Requirements

LDL depends on a counter called _systemtime_ which counts up from zero (at system reset) at a rate of
one tick every 10us. The MAC reads _systemtime_ by calling MAC.time().

On an MCU _systemtime_ could be implemented using a free-running timer/counter where:

- An overflow interrupt increments the most significant digits of a software counter
- A compare match interrupt can be used to schedule wake up events which
  are know to occur before the next overflow
- The least significant digits can be read directly from the counter register
  
The MAC needs to be able to service timeout events promptly. Below is the basic send
and receive pattern implemented by a LoRaWAN device.

![image missing](/doc/plantuml/rx_windows.png "RX Timing")

- The device turns on its radio to TX a message
- The device captures a timestamp at the moment TX completes and calculates the time for RX1_START and RX2_START
- The device turns on its radio at RX1_START and RX2_START (+/- 10us) to listen for downstream messages
- RX1_INTERVAL is configured to be between 1 and 16 seconds (in one second increments)
- RX2_INTERVAL is always 1 greater than RX1_INTERVAL

If the event is early, the MAC will need to open the window early which will require more energy. If the event is late, the MAC
will miss the downstream window.
